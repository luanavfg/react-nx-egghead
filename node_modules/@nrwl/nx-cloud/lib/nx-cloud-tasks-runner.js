"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const tasks_runner_v2_1 = require("@nrwl/workspace/src/tasks-runner/tasks-runner-v2");
const output_1 = require("@nrwl/workspace/src/utils/output");
const fs = require("fs");
const fs_1 = require("fs");
const path = require("path");
const uuid_1 = require("uuid");
const crypto = require("crypto");
const node_machine_id_1 = require("node-machine-id");
const axios = require('axios');
const tar = require('tar');
const chalk = require('chalk');
class CloudApi {
    constructor(messages, baseUrl, authToken, machineId) {
        this.messages = messages;
        this.machineId = machineId;
        this.apiAxiosInstance = axios.create({
            baseURL: baseUrl,
            timeout: 10000,
            headers: { authorization: authToken },
        });
    }
    startRun(hashes) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.apiAxiosInstance.post('/nx-cloud/runs/start', {
                    meta: {
                        nxCloudVersion: this.nxCloudVersion(),
                    },
                    hashes,
                });
                if (resp.data && resp.data.message) {
                    this.messages.message = resp.data.message;
                }
                if (!resp.data || !resp.data.urls) {
                    this.messages.apiError = `Invalid Nx Cloud response: ${JSON.stringify(resp.data)}`;
                    return {};
                }
                return resp.data.urls;
            }
            catch (e) {
                this.messages.apiError = this.messages.extractErrorMessage(e, 'api');
                return {};
            }
        });
    }
    endRun(tasks) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // API is not working, don't make the end request
                if (this.messages.apiError)
                    return;
                const resp = yield this.apiAxiosInstance.post('/nx-cloud/runs/end', {
                    tasks,
                    machineId: this.machineId,
                });
                if (!resp.data || resp.data !== 'success') {
                    this.messages.apiError = `Invalid end run response: ${JSON.stringify(resp.data)}`;
                }
            }
            catch (e) {
                this.messages.apiError = this.messages.extractErrorMessage(e, 'api');
            }
        });
    }
    nxCloudVersion() {
        try {
            const v = JSON.parse(fs.readFileSync(`package.json`).toString());
            return v.devDependencies['@nrwl/nx-cloud'];
        }
        catch (e) {
            return 'unknown';
        }
    }
    findSimilarTasks(task) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // API is not working, don't make the end request
                if (this.messages.apiError)
                    return null;
                const resp = yield this.apiAxiosInstance.post('/nx-cloud/find-similar-tasks', {
                    task: {
                        target: task.target,
                        projectName: task.projectName,
                        hash: task.hash,
                        hashDetails: task.hashDetails,
                    },
                });
                if (!resp.data) {
                    this.messages.apiError = `Invalid end run response: ${JSON.stringify(resp.data)}`;
                }
                return resp.data.message;
            }
            catch (e) {
                this.messages.apiError = this.messages.extractErrorMessage(e, 'api');
                return null;
            }
        });
    }
}
class E2EEncryption {
    constructor(key) {
        if (key) {
            this.encryptionKey = this.to32bytes(key);
        }
    }
    to32bytes(key) {
        let res = key;
        while (res.length < 32) {
            res += key;
        }
        return Buffer.from(res).slice(0, 32);
    }
    hasEncryption() {
        return !!this.encryptionKey;
    }
    encryptFile(file) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);
        const decryptedFileContents = fs.readFileSync(file);
        const e = cipher.update(decryptedFileContents);
        const encryptedFileContents = Buffer.concat([iv, e, cipher.final()]);
        fs.writeFileSync(file, encryptedFileContents);
    }
    decryptFile(file) {
        const encryptedFileContents = fs.readFileSync(file);
        try {
            const decipher = crypto.createDecipheriv('aes-256-cbc', this.encryptionKey, encryptedFileContents.slice(0, 16) // iv
            );
            const encryptedText = encryptedFileContents.slice(16); // remove the iv
            const d = decipher.update(encryptedText);
            const decryptedFileContents = Buffer.concat([d, decipher.final()]);
            fs.writeFileSync(file, decryptedFileContents);
        }
        catch (e) {
            throw new Error(`Could not decrypt the artifact. Please check your encryption key.`);
        }
    }
}
class CloudRemoteCache {
    constructor(messages, urls, statuses, encryption) {
        this.messages = messages;
        this.urls = urls;
        this.statuses = statuses;
        this.encryption = encryption;
        this.storeRequests = [];
    }
    retrieve(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.messages.cacheError)
                return false;
            try {
                const hashUrls = (yield this.urls)[hash];
                if (!hashUrls || !hashUrls.get)
                    return false;
                if (CloudRemoteCache.VERBOSE_LOGGING) {
                    output_1.output.note({ title: `Nx Cloud: Downloading ${hash}` });
                }
                const tgz = this.createFileName(hash, cacheDirectory);
                yield this.downloadFile(hashUrls.get, tgz);
                this.createCommitFile(hash, cacheDirectory);
                if (CloudRemoteCache.VERBOSE_LOGGING) {
                    output_1.output.note({ title: `Nx Cloud: Cache hit ${hash}` });
                }
                this.statuses[hash] = 'remote-cache-hit';
                return true;
            }
            catch (e) {
                if (e.response && e.response.status === 404) {
                    if (CloudRemoteCache.VERBOSE_LOGGING) {
                        output_1.output.note({ title: `Nx Cloud: Cache miss ${hash}` });
                    }
                    // cache miss. print nothing
                }
                else {
                    this.messages.cacheError = this.messages.extractErrorMessage(e, 'storage');
                }
                this.statuses[hash] = 'remote-cache-miss';
                return false;
            }
        });
    }
    store(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.messages.cacheError)
                return false;
            const res = Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
                const hashUrls = (yield this.urls)[hash];
                if (!hashUrls)
                    return false;
                if (!hashUrls.put) {
                    if (CloudRemoteCache.VERBOSE_LOGGING) {
                        output_1.output.note({
                            title: `Nx Cloud: Skipping storing ${hash}. Read only token is used.`,
                        });
                    }
                    return true;
                }
                try {
                    if (CloudRemoteCache.VERBOSE_LOGGING) {
                        output_1.output.note({ title: `Nx Cloud: Storing ${hash}` });
                    }
                    const tgz = yield this.createFile(hash, cacheDirectory);
                    yield this.uploadFile(hashUrls.put, tgz);
                    if (CloudRemoteCache.VERBOSE_LOGGING) {
                        output_1.output.note({ title: `Nx Cloud: Stored ${hash}` });
                    }
                    return true;
                }
                catch (e) {
                    this.messages.cacheError = this.messages.extractErrorMessage(e, 'storage');
                    return false;
                }
            }));
            this.storeRequests.push(res);
            return res;
        });
    }
    waitForStoreRequestsToComplete() {
        return Promise.all(this.storeRequests);
    }
    createFileName(hash, cacheDirectory) {
        return path.join(cacheDirectory, `${hash}.tar.gz`);
    }
    downloadFile(url, tgz) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios(url, {
                method: 'GET',
                responseType: 'stream',
                maxContentLength: 1000 * 1000 * 200,
                timeout: 30000,
            });
            if (this.encryption.hasEncryption()) {
                yield new Promise((res) => {
                    const f = resp.data.pipe(fs.createWriteStream(tgz));
                    f.on('close', () => res());
                });
                this.encryption.decryptFile(tgz);
                const q = fs.createReadStream(tgz).pipe(tar.x({
                    cwd: path.dirname(tgz),
                }));
                return new Promise((res) => {
                    q.on('close', () => {
                        res();
                    });
                });
            }
            else {
                const q = resp.data.pipe(tar.x({
                    cwd: path.dirname(tgz),
                }));
                return new Promise((res) => {
                    q.on('close', () => {
                        res();
                    });
                });
            }
        });
    }
    createCommitFile(hash, cacheDirectory) {
        fs_1.writeFileSync(path.join(cacheDirectory, `${hash}.commit`), 'true');
    }
    createFile(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            const tgz = this.createFileName(hash, cacheDirectory);
            yield tar.c({
                gzip: true,
                file: tgz,
                cwd: cacheDirectory,
            }, [hash]);
            if (this.encryption.hasEncryption()) {
                this.encryption.encryptFile(tgz);
            }
            return tgz;
        });
    }
    uploadFile(url, tgz) {
        return __awaiter(this, void 0, void 0, function* () {
            yield axios(url, {
                method: 'PUT',
                data: fs.readFileSync(tgz),
                headers: { 'Content-Type': 'application/octet-stream' },
                maxContentLength: 1000 * 1000 * 200,
            });
        });
    }
}
CloudRemoteCache.VERBOSE_LOGGING = process.env.NX_VERBOSE_LOGGING;
class TaskRunnerLifeCycle {
    constructor(statuses) {
        this.statuses = statuses;
        this.tasks = [];
        this.uniqRunId = uuid_1.v4();
    }
    startTask(task) {
        const overrides = Object.assign({}, (task.overrides || {}));
        if (task.target.configuration) {
            overrides['configuration'] = task.target.configuration;
        }
        const params = Object.keys(overrides).reduce((m, k) => `${m} --${k}=${overrides[k]}`, ``);
        this.tasks.push({
            taskId: `${task.id}-${this.uniqRunId}`,
            startTime: new Date().toISOString(),
            target: task.target.target,
            projectName: task.target.project,
            hash: task.hash,
            hashDetails: task.hashDetails,
            params: params,
        });
    }
    endTask(task, code) {
        const startedTask = this.tasks.find((t) => t.taskId === `${task.id}-${this.uniqRunId}`);
        if (!startedTask) {
            throw new Error(`Cannot find task ${task.id}`);
        }
        startedTask.endTime = new Date().toISOString();
        startedTask.status = code;
        startedTask.cacheStatus = this.statuses[task.hash] || 'no-remote-cache';
    }
}
class MessageReporter {
    constructor(options) {
        this.options = options;
        this.cacheError = null;
        this.apiError = null;
        this.message = null;
    }
    get anyErrors() {
        return this.cacheError || this.apiError;
    }
    printMessages() {
        if (this.anyErrors) {
            const bodyLines = [];
            if (this.cacheError) {
                bodyLines.push(`- ${this.cacheError}`);
            }
            if (this.apiError && this.apiError !== this.cacheError) {
                bodyLines.push(`- ${this.apiError}`);
            }
            output_1.output.warn({
                title: `Nx Cloud Problems`,
                bodyLines,
            });
        }
        if (this.message) {
            printMessage(this.message);
        }
    }
    extractErrorMessage(e, scope) {
        if (e.code === 'ECONNREFUSED' ||
            e.code === 'EAI_AGAIN' ||
            e.code === 'ENOTFOUND' ||
            e.code === 'EPROTO' ||
            e.code === 'ECONNABORTED') {
            return `Cannot connect to remote cache (scope: ${scope}, code: ${e.code}).`;
        }
        else if (e.response && e.response.status === 401) {
            return e.response.data.message
                ? e.response.data.message
                : e.response.data;
        }
        else if (e.response && e.response.status === 402) {
            if (this.options.showUsageWarnings === false)
                return null;
            return e.response.data.message
                ? e.response.data.message
                : e.response.data;
        }
        else {
            let details = '';
            if (e.response && e.response.data && e.response.data.message) {
                details = `. ${e.response.data.message}`;
            }
            else if (e.response && e.response.data) {
                details = `. ${e.response.data}`;
            }
            return `${e.message}${details} (code: ${e.code})`;
        }
    }
}
class CacheMissAssistant {
    constructor(messages, statuses, api) {
        this.messages = messages;
        this.statuses = statuses;
        this.api = api;
    }
    findSimilarTasksForFirstTaskWithCacheMiss(tasks) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.messages.anyErrors || !CacheMissAssistant.VERBOSE_LOGGING)
                return;
            const missedTask = tasks.find((t) => this.statuses[t.hash] === 'remote-cache-miss');
            if (missedTask) {
                const r = yield this.api.findSimilarTasks(missedTask);
                if (r) {
                    output_1.output.note({
                        title: `Nx Cloud cache miss analysis:`,
                        bodyLines: r.split('\n'),
                    });
                }
            }
        });
    }
}
CacheMissAssistant.VERBOSE_LOGGING = process.env.NX_VERBOSE_LOGGING;
class CacheHitMessage {
    constructor(messages, statuses) {
        this.messages = messages;
        this.statuses = statuses;
        this.tasks = [];
        this.patchReporters();
    }
    // We patch reporters temporary. Nx 10 should have a proper way of printing remote cache hits.
    patchReporters() {
        try {
            const reporter = require('@nrwl/workspace/src/tasks-runner/default-reporter');
            const old = reporter.DefaultReporter.prototype.printResults;
            const that = this;
            reporter.DefaultReporter.prototype.printResults = function () {
                old.apply(this, arguments);
                that.printCacheHitsMessage();
            };
        }
        catch (e) { }
        try {
            const reporter = require('@nrwl/workspace/src/tasks-runner/run-one-reporter');
            const old = reporter.RunOneReporter.prototype.printResults;
            const that = this;
            reporter.RunOneReporter.prototype.printResults = function () {
                old.apply(this, arguments);
                that.printCacheHitsMessage();
            };
        }
        catch (e) { }
        try {
            const reporter = require('@nrwl/workspace/src/tasks-runner/empty-reporter');
            const old = reporter.EmptyReporter.prototype.printResults;
            const that = this;
            reporter.EmptyReporter.prototype.printResults = function () {
                old.apply(this, arguments);
                that.printCacheHitsMessage();
            };
        }
        catch (e) { }
    }
    printCacheHitsMessage() {
        if (this.messages.anyErrors)
            return;
        const hits = this.tasks
            .filter((t) => this.statuses[t.hash] === 'remote-cache-hit')
            .map((t) => t.projectName);
        if (hits.length === 0) {
            return;
        }
        const projects = hits.length === 1 ? hits[0] : `${hits.length} projects`;
        printMessage(`Results for ${projects} were retrieved from Nx Cloud.`);
    }
}
function printMessage(message) {
    const formattedMessage = output_1.output.colors.gray(message);
    output_1.output.addNewline();
    output_1.output.writeOutputTitle({
        label: chalk.reset.inverse.bold.keyword('grey')(' CLOUD '),
        title: chalk.keyword('grey')(formattedMessage),
    });
    output_1.output.addNewline();
}
function getMachineId(options) {
    if (options.canTrackAnalytics) {
        try {
            return node_machine_id_1.machineIdSync();
        }
        catch (_a) {
            return 'error';
        }
    }
    else if (options.canTrackAnalytics === false) {
        //if it was explicitly set to false when the user was prompted
        return 'opt-out';
    }
    else {
        //if option is undefined and missing altogether, assume the user was never prompted
        return null;
    }
}
function createApi(errors, options) {
    const baseUrl = options.url || 'https://api.nrwl.io';
    const machineId = getMachineId(options);
    if (process.env.NX_CLOUD_AUTH_TOKEN) {
        return new CloudApi(errors, baseUrl, process.env.NX_CLOUD_AUTH_TOKEN, machineId);
    }
    else {
        return new CloudApi(errors, baseUrl, options.accessToken, machineId);
    }
}
const nxCloudTasksRunner = (tasks, options, context) => {
    if (process.env.NX_CLOUD_AUTH_TOKEN || options.accessToken) {
        const statuses = {};
        const messages = new MessageReporter(options);
        const api = createApi(messages, options);
        const cacheMissAssistant = new CacheMissAssistant(messages, statuses, api);
        const cacheHitMessage = new CacheHitMessage(messages, statuses);
        const urls = api.startRun(tasks.map((t) => t.hash));
        const lifeCycle = new TaskRunnerLifeCycle(statuses);
        const encryption = new E2EEncryption(process.env.NX_CLOUD_ENCRYPTION_KEY || options.encryptionKey);
        const remoteCache = new CloudRemoteCache(messages, urls, statuses, encryption);
        const res = tasks_runner_v2_1.tasksRunnerV2(tasks, Object.assign(Object.assign({}, options), { remoteCache, lifeCycle }), context);
        const wrappedRes = new rxjs_1.Subject();
        res.subscribe({
            next: (value) => wrappedRes.next(value),
            error: (err) => wrappedRes.error(err),
            complete: () => __awaiter(void 0, void 0, void 0, function* () {
                yield Promise.all([
                    remoteCache.waitForStoreRequestsToComplete(),
                    api.endRun(lifeCycle.tasks),
                ]);
                messages.printMessages();
                yield cacheMissAssistant.findSimilarTasksForFirstTaskWithCacheMiss(lifeCycle.tasks);
                cacheHitMessage.tasks = lifeCycle.tasks;
                wrappedRes.complete();
            }),
        });
        return wrappedRes;
    }
    else {
        return tasks_runner_v2_1.tasksRunnerV2(tasks, options, context);
    }
};
exports.default = nxCloudTasksRunner;
//# sourceMappingURL=nx-cloud-tasks-runner.js.map